
nrf8001.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000308  00800100  000004ca  0000053e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004ca  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  00000846  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 000000e8  00000000  00000000  00000876  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000008ac  00000000  00000000  0000095e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000003ee  00000000  00000000  0000120a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000492  00000000  00000000  000015f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000240  00000000  00000000  00001a8c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000266  00000000  00000000  00001ccc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000566  00000000  00000000  00001f32  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000000a8  00000000  00000000  00002498  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 89 00 	jmp	0x112	; 0x112 <__ctors_end>
   4:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
   8:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
   c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  10:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  14:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  18:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  1c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  20:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  24:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  28:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  2c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  30:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  34:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  38:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  3c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  40:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  44:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  48:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  4c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  50:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  54:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  58:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  5c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  60:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  64:	0c 94 ac 00 	jmp	0x158	; 0x158 <__vector_25>
  68:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  6c:	0c 94 a0 00 	jmp	0x140	; 0x140 <__vector_27>
  70:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  74:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  78:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  7c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  80:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  84:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  88:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  8c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  90:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  94:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  98:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  9c:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  a0:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  a4:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  a8:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__bad_interrupt>
  ac:	cb 00       	.word	0x00cb	; ????
  ae:	ce 00       	.word	0x00ce	; ????
  b0:	e2 00       	.word	0x00e2	; ????
  b2:	e2 00       	.word	0x00e2	; ????
  b4:	e2 00       	.word	0x00e2	; ????
  b6:	e2 00       	.word	0x00e2	; ????
  b8:	e2 00       	.word	0x00e2	; ????
  ba:	e2 00       	.word	0x00e2	; ????
  bc:	e2 00       	.word	0x00e2	; ????
  be:	e2 00       	.word	0x00e2	; ????
  c0:	e2 00       	.word	0x00e2	; ????
  c2:	e2 00       	.word	0x00e2	; ????
  c4:	e2 00       	.word	0x00e2	; ????
  c6:	e2 00       	.word	0x00e2	; ????
  c8:	e2 00       	.word	0x00e2	; ????
  ca:	e2 00       	.word	0x00e2	; ????
  cc:	e2 00       	.word	0x00e2	; ????
  ce:	da 00       	.word	0x00da	; ????
  d0:	dd 00       	.word	0x00dd	; ????
  d2:	e2 00       	.word	0x00e2	; ????
  d4:	e2 00       	.word	0x00e2	; ????
  d6:	e2 00       	.word	0x00e2	; ????
  d8:	e2 00       	.word	0x00e2	; ????
  da:	e2 00       	.word	0x00e2	; ????
  dc:	e2 00       	.word	0x00e2	; ????
  de:	e2 00       	.word	0x00e2	; ????
  e0:	e2 00       	.word	0x00e2	; ????
  e2:	e2 00       	.word	0x00e2	; ????
  e4:	e2 00       	.word	0x00e2	; ????
  e6:	e2 00       	.word	0x00e2	; ????
  e8:	e2 00       	.word	0x00e2	; ????
  ea:	e2 00       	.word	0x00e2	; ????
  ec:	cb 00       	.word	0x00cb	; ????
  ee:	d4 00       	.word	0x00d4	; ????
  f0:	e2 00       	.word	0x00e2	; ????
  f2:	e2 00       	.word	0x00e2	; ????
  f4:	e2 00       	.word	0x00e2	; ????
  f6:	e2 00       	.word	0x00e2	; ????
  f8:	e2 00       	.word	0x00e2	; ????
  fa:	e2 00       	.word	0x00e2	; ????
  fc:	e2 00       	.word	0x00e2	; ????
  fe:	e2 00       	.word	0x00e2	; ????
 100:	e2 00       	.word	0x00e2	; ????
 102:	e2 00       	.word	0x00e2	; ????
 104:	e2 00       	.word	0x00e2	; ????
 106:	e2 00       	.word	0x00e2	; ????
 108:	e2 00       	.word	0x00e2	; ????
 10a:	e2 00       	.word	0x00e2	; ????
 10c:	e2 00       	.word	0x00e2	; ????
 10e:	da 00       	.word	0x00da	; ????
 110:	dd 00       	.word	0x00dd	; ????

00000112 <__ctors_end>:
 112:	11 24       	eor	r1, r1
 114:	1f be       	out	0x3f, r1	; 63
 116:	cf ef       	ldi	r28, 0xFF	; 255
 118:	da e0       	ldi	r29, 0x0A	; 10
 11a:	de bf       	out	0x3e, r29	; 62
 11c:	cd bf       	out	0x3d, r28	; 61

0000011e <__do_copy_data>:
 11e:	14 e0       	ldi	r17, 0x04	; 4
 120:	a0 e0       	ldi	r26, 0x00	; 0
 122:	b1 e0       	ldi	r27, 0x01	; 1
 124:	ea ec       	ldi	r30, 0xCA	; 202
 126:	f4 e0       	ldi	r31, 0x04	; 4
 128:	02 c0       	rjmp	.+4      	; 0x12e <__do_copy_data+0x10>
 12a:	05 90       	lpm	r0, Z+
 12c:	0d 92       	st	X+, r0
 12e:	a8 30       	cpi	r26, 0x08	; 8
 130:	b1 07       	cpc	r27, r17
 132:	d9 f7       	brne	.-10     	; 0x12a <__do_copy_data+0xc>
 134:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <main>
 138:	0c 94 63 02 	jmp	0x4c6	; 0x4c6 <_exit>

0000013c <__bad_interrupt>:
 13c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000140 <__vector_27>:


/*
 * ISR functions
 */
ISR(USART1_TX_vect){
 140:	1f 92       	push	r1
 142:	0f 92       	push	r0
 144:	0f b6       	in	r0, 0x3f	; 63
 146:	0f 92       	push	r0
 148:	11 24       	eor	r1, r1
	cli();
 14a:	f8 94       	cli
	sei();
 14c:	78 94       	sei
}
 14e:	0f 90       	pop	r0
 150:	0f be       	out	0x3f, r0	; 63
 152:	0f 90       	pop	r0
 154:	1f 90       	pop	r1
 156:	18 95       	reti

00000158 <__vector_25>:

ISR(USART1_RX_vect){
 158:	1f 92       	push	r1
 15a:	0f 92       	push	r0
 15c:	0f b6       	in	r0, 0x3f	; 63
 15e:	0f 92       	push	r0
 160:	11 24       	eor	r1, r1
 162:	2f 93       	push	r18
 164:	3f 93       	push	r19
 166:	4f 93       	push	r20
 168:	5f 93       	push	r21
 16a:	6f 93       	push	r22
 16c:	7f 93       	push	r23
 16e:	8f 93       	push	r24
 170:	9f 93       	push	r25
 172:	af 93       	push	r26
 174:	bf 93       	push	r27
 176:	ef 93       	push	r30
 178:	ff 93       	push	r31
	cli();
 17a:	f8 94       	cli
	unsigned char uart_dr=UDR1;
 17c:	80 91 ce 00 	lds	r24, 0x00CE
	switch(uart_dr) {
 180:	90 e0       	ldi	r25, 0x00	; 0
 182:	fc 01       	movw	r30, r24
 184:	e1 54       	subi	r30, 0x41	; 65
 186:	f1 09       	sbc	r31, r1
 188:	e3 33       	cpi	r30, 0x33	; 51
 18a:	f1 05       	cpc	r31, r1
 18c:	d8 f4       	brcc	.+54     	; 0x1c4 <__vector_25+0x6c>
 18e:	ea 5a       	subi	r30, 0xAA	; 170
 190:	ff 4f       	sbci	r31, 0xFF	; 255
 192:	0c 94 5d 02 	jmp	0x4ba	; 0x4ba <__tablejump2__>
		case 'A':
		case 'a':
			nrf_advertise();
 196:	0e 94 95 01 	call	0x32a	; 0x32a <nrf_advertise>
			break;
 19a:	14 c0       	rjmp	.+40     	; 0x1c4 <__vector_25+0x6c>
		case 'B':
			uart_println((uint8_t *) &PORTB, 1);
 19c:	61 e0       	ldi	r22, 0x01	; 1
 19e:	85 e2       	ldi	r24, 0x25	; 37
 1a0:	90 e0       	ldi	r25, 0x00	; 0
 1a2:	0e 94 4a 02 	call	0x494	; 0x494 <uart_println>
			break;
 1a6:	0e c0       	rjmp	.+28     	; 0x1c4 <__vector_25+0x6c>
		case 'b':
			uart_println((uint8_t *) &PINB, 1);
 1a8:	61 e0       	ldi	r22, 0x01	; 1
 1aa:	83 e2       	ldi	r24, 0x23	; 35
 1ac:	90 e0       	ldi	r25, 0x00	; 0
 1ae:	0e 94 4a 02 	call	0x494	; 0x494 <uart_println>
			break;
 1b2:	08 c0       	rjmp	.+16     	; 0x1c4 <__vector_25+0x6c>
		case 'R':
		case 'r':
			nrf_receive_packet();
 1b4:	0e 94 29 01 	call	0x252	; 0x252 <nrf_receive_packet>
			break;
 1b8:	05 c0       	rjmp	.+10     	; 0x1c4 <__vector_25+0x6c>
		case 'S':
		case 's':
			nrf_send_data((uint8_t *) "A message!", 10);
 1ba:	6a e0       	ldi	r22, 0x0A	; 10
 1bc:	80 ea       	ldi	r24, 0xA0	; 160
 1be:	93 e0       	ldi	r25, 0x03	; 3
 1c0:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <nrf_send_data>
			break;
	}
	sei();
 1c4:	78 94       	sei
}
 1c6:	ff 91       	pop	r31
 1c8:	ef 91       	pop	r30
 1ca:	bf 91       	pop	r27
 1cc:	af 91       	pop	r26
 1ce:	9f 91       	pop	r25
 1d0:	8f 91       	pop	r24
 1d2:	7f 91       	pop	r23
 1d4:	6f 91       	pop	r22
 1d6:	5f 91       	pop	r21
 1d8:	4f 91       	pop	r20
 1da:	3f 91       	pop	r19
 1dc:	2f 91       	pop	r18
 1de:	0f 90       	pop	r0
 1e0:	0f be       	out	0x3f, r0	; 63
 1e2:	0f 90       	pop	r0
 1e4:	1f 90       	pop	r1
 1e6:	18 95       	reti

000001e8 <pre_stuff>:
/*
 * FUNCTION IMPLEMENTATIONS
 */
void pre_stuff(void) {
	// Remove CLKDIV8
	CLKPR = 0x80;
 1e8:	e1 e6       	ldi	r30, 0x61	; 97
 1ea:	f0 e0       	ldi	r31, 0x00	; 0
 1ec:	80 e8       	ldi	r24, 0x80	; 128
 1ee:	80 83       	st	Z, r24
	CLKPR = 0x00;
 1f0:	10 82       	st	Z, r1
	// DISABLE JTAG - take control of F port
	MCUCR = _BV(JTD);
 1f2:	85 bf       	out	0x35, r24	; 53
	MCUCR = _BV(JTD);
 1f4:	85 bf       	out	0x35, r24	; 53
 1f6:	08 95       	ret

000001f8 <main>:
/*
 * MAIN FUNCTION
 */
int main(void) {
	// setup
	pre_stuff();
 1f8:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <pre_stuff>
	uart_init();
 1fc:	0e 94 22 02 	call	0x444	; 0x444 <uart_init>
	spi_init();
 200:	0e 94 04 02 	call	0x408	; 0x408 <spi_init>
	
	uart_println((uint8_t *) "Program started!", 16);
 204:	60 e1       	ldi	r22, 0x10	; 16
 206:	8b ea       	ldi	r24, 0xAB	; 171
 208:	93 e0       	ldi	r25, 0x03	; 3
 20a:	0e 94 4a 02 	call	0x494	; 0x494 <uart_println>
	
	nrf_setup();
 20e:	0e 94 bb 01 	call	0x376	; 0x376 <nrf_setup>
	
	// main loop
	sei();
 212:	78 94       	sei
	uart_println((uint8_t *) "Entering main!", 14);
 214:	6e e0       	ldi	r22, 0x0E	; 14
 216:	8c eb       	ldi	r24, 0xBC	; 188
 218:	93 e0       	ldi	r25, 0x03	; 3
 21a:	0e 94 4a 02 	call	0x494	; 0x494 <uart_println>
    while(1) {
        if ((NRF_PIN & (1<<NRF_RDY)) == 0)
 21e:	1c 99       	sbic	0x03, 4	; 3
 220:	fe cf       	rjmp	.-4      	; 0x21e <main+0x26>
			nrf_receive_packet();
 222:	0e 94 29 01 	call	0x252	; 0x252 <nrf_receive_packet>
 226:	fb cf       	rjmp	.-10     	; 0x21e <main+0x26>

00000228 <nrf_wait_for_rdy>:
#include "../Include/nrf8001_api.h"
#include "../Include/SPI_api.h"
#include "../Include/UART_api.h"

void nrf_wait_for_rdy(void) {
	while((NRF_PIN & (1<<NRF_RDY)) !=0);
 228:	1c 99       	sbic	0x03, 4	; 3
 22a:	fe cf       	rjmp	.-4      	; 0x228 <nrf_wait_for_rdy>
}
 22c:	08 95       	ret

0000022e <nrf_send_packet>:

void nrf_send_packet(uint8_t *packet) {
 22e:	1f 93       	push	r17
 230:	cf 93       	push	r28
 232:	df 93       	push	r29
 234:	ec 01       	movw	r28, r24
	uint8_t length = (*packet) +1;
 236:	18 81       	ld	r17, Y
 238:	1f 5f       	subi	r17, 0xFF	; 255
	NRF_START_TRANSMISSION;
 23a:	28 98       	cbi	0x05, 0	; 5
	nrf_wait_for_rdy();
 23c:	0e 94 14 01 	call	0x228	; 0x228 <nrf_wait_for_rdy>

	spi_tranceive(packet, length);
 240:	61 2f       	mov	r22, r17
 242:	ce 01       	movw	r24, r28
 244:	0e 94 0d 02 	call	0x41a	; 0x41a <spi_tranceive>

	NRF_END_TRANSMISSION;
 248:	28 9a       	sbi	0x05, 0	; 5
}
 24a:	df 91       	pop	r29
 24c:	cf 91       	pop	r28
 24e:	1f 91       	pop	r17
 250:	08 95       	ret

00000252 <nrf_receive_packet>:

void nrf_receive_packet(void) {
 252:	1f 93       	push	r17
 254:	cf 93       	push	r28
 256:	df 93       	push	r29
 258:	00 d0       	rcall	.+0      	; 0x25a <nrf_receive_packet+0x8>
 25a:	cd b7       	in	r28, 0x3d	; 61
 25c:	de b7       	in	r29, 0x3e	; 62
	uint8_t nrf_data = 0;
 25e:	19 82       	std	Y+1, r1	; 0x01
	uint8_t nrf_packet_len = 0;
 260:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t index;
	NRF_START_TRANSMISSION;
 262:	28 98       	cbi	0x05, 0	; 5
	nrf_wait_for_rdy();
 264:	0e 94 14 01 	call	0x228	; 0x228 <nrf_wait_for_rdy>
	// first byte is nrf debugging byte...
	spi_receive();
 268:	0e 94 1c 02 	call	0x438	; 0x438 <spi_receive>
	// second byte of packet - packet length (length packet excluded)
	nrf_packet_len = spi_receive();
 26c:	0e 94 1c 02 	call	0x438	; 0x438 <spi_receive>
 270:	8a 83       	std	Y+2, r24	; 0x02
	uart_print(&nrf_packet_len, 1);
 272:	61 e0       	ldi	r22, 0x01	; 1
 274:	ce 01       	movw	r24, r28
 276:	02 96       	adiw	r24, 0x02	; 2
 278:	0e 94 34 02 	call	0x468	; 0x468 <uart_print>
	// trailing data
	for(index=0; index<nrf_packet_len; index++) {
 27c:	8a 81       	ldd	r24, Y+2	; 0x02
 27e:	88 23       	and	r24, r24
 280:	69 f0       	breq	.+26     	; 0x29c <nrf_receive_packet+0x4a>
 282:	10 e0       	ldi	r17, 0x00	; 0
		nrf_data = spi_receive();
 284:	0e 94 1c 02 	call	0x438	; 0x438 <spi_receive>
 288:	89 83       	std	Y+1, r24	; 0x01
		uart_print(&nrf_data, 1);
 28a:	61 e0       	ldi	r22, 0x01	; 1
 28c:	ce 01       	movw	r24, r28
 28e:	01 96       	adiw	r24, 0x01	; 1
 290:	0e 94 34 02 	call	0x468	; 0x468 <uart_print>
	spi_receive();
	// second byte of packet - packet length (length packet excluded)
	nrf_packet_len = spi_receive();
	uart_print(&nrf_packet_len, 1);
	// trailing data
	for(index=0; index<nrf_packet_len; index++) {
 294:	1f 5f       	subi	r17, 0xFF	; 255
 296:	8a 81       	ldd	r24, Y+2	; 0x02
 298:	18 17       	cp	r17, r24
 29a:	a0 f3       	brcs	.-24     	; 0x284 <nrf_receive_packet+0x32>
		nrf_data = spi_receive();
		uart_print(&nrf_data, 1);
	}
	uart_println((uint8_t *) "", 0);
 29c:	60 e0       	ldi	r22, 0x00	; 0
 29e:	8b eb       	ldi	r24, 0xBB	; 187
 2a0:	93 e0       	ldi	r25, 0x03	; 3
 2a2:	0e 94 4a 02 	call	0x494	; 0x494 <uart_println>
	NRF_END_TRANSMISSION;
 2a6:	28 9a       	sbi	0x05, 0	; 5
}
 2a8:	0f 90       	pop	r0
 2aa:	0f 90       	pop	r0
 2ac:	df 91       	pop	r29
 2ae:	cf 91       	pop	r28
 2b0:	1f 91       	pop	r17
 2b2:	08 95       	ret

000002b4 <nrf_send_setup_data>:

void nrf_send_setup_data(void) {
 2b4:	ef 92       	push	r14
 2b6:	ff 92       	push	r15
 2b8:	0f 93       	push	r16
 2ba:	1f 93       	push	r17
 2bc:	cf 93       	push	r28
 2be:	df 93       	push	r29
 2c0:	cd b7       	in	r28, 0x3d	; 61
 2c2:	de b7       	in	r29, 0x3e	; 62
 2c4:	c0 5a       	subi	r28, 0xA0	; 160
 2c6:	d2 40       	sbci	r29, 0x02	; 2
 2c8:	0f b6       	in	r0, 0x3f	; 63
 2ca:	f8 94       	cli
 2cc:	de bf       	out	0x3e, r29	; 62
 2ce:	0f be       	out	0x3f, r0	; 63
 2d0:	cd bf       	out	0x3d, r28	; 61
	uint8_t index;
	uint8_t setup_data[NB_SETUP_MESSAGES][SETUP_PACKET_LENGTH] = {
 2d2:	80 ea       	ldi	r24, 0xA0	; 160
 2d4:	92 e0       	ldi	r25, 0x02	; 2
 2d6:	e0 e0       	ldi	r30, 0x00	; 0
 2d8:	f1 e0       	ldi	r31, 0x01	; 1
 2da:	de 01       	movw	r26, r28
 2dc:	11 96       	adiw	r26, 0x01	; 1
 2de:	01 90       	ld	r0, Z+
 2e0:	0d 92       	st	X+, r0
 2e2:	01 97       	sbiw	r24, 0x01	; 1
 2e4:	e1 f7       	brne	.-8      	; 0x2de <nrf_send_setup_data+0x2a>
 2e6:	8e 01       	movw	r16, r28
 2e8:	0f 5f       	subi	r16, 0xFF	; 255
 2ea:	1f 4f       	sbci	r17, 0xFF	; 255
 2ec:	7e 01       	movw	r14, r28
 2ee:	8f e5       	ldi	r24, 0x5F	; 95
 2f0:	e8 1a       	sub	r14, r24
 2f2:	8d ef       	ldi	r24, 0xFD	; 253
 2f4:	f8 0a       	sbc	r15, r24
		{0x13,0x06,0x50,0x00,0x9e,0xca,0xdc,0x24,0x0e,0xe5,0xa9,0xe0,0x93,0xf3,0xa3,0xb5,0x00,0x00,0x40,0x6e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x0f,0x06,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x06,0x06,0xf0,0x00,0x03,0xd3,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
	};
	for (index=0; index<NB_SETUP_MESSAGES; index++) {
		nrf_send_packet(setup_data[index]);
 2f6:	c8 01       	movw	r24, r16
 2f8:	0e 94 17 01 	call	0x22e	; 0x22e <nrf_send_packet>
		nrf_wait_for_rdy();
 2fc:	0e 94 14 01 	call	0x228	; 0x228 <nrf_wait_for_rdy>
		// recieve acknowledge
		nrf_receive_packet();
 300:	0e 94 29 01 	call	0x252	; 0x252 <nrf_receive_packet>
 304:	00 5e       	subi	r16, 0xE0	; 224
 306:	1f 4f       	sbci	r17, 0xFF	; 255
		{0x0f,0x06,0x40,0x1c,0x00,0x0e,0x2a,0x27,0x01,0x00,0x80,0x04,0x00,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x13,0x06,0x50,0x00,0x9e,0xca,0xdc,0x24,0x0e,0xe5,0xa9,0xe0,0x93,0xf3,0xa3,0xb5,0x00,0x00,0x40,0x6e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x0f,0x06,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x06,0x06,0xf0,0x00,0x03,0xd3,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
	};
	for (index=0; index<NB_SETUP_MESSAGES; index++) {
 308:	0e 15       	cp	r16, r14
 30a:	1f 05       	cpc	r17, r15
 30c:	a1 f7       	brne	.-24     	; 0x2f6 <nrf_send_setup_data+0x42>
		nrf_send_packet(setup_data[index]);
		nrf_wait_for_rdy();
		// recieve acknowledge
		nrf_receive_packet();
	}
}
 30e:	c0 56       	subi	r28, 0x60	; 96
 310:	dd 4f       	sbci	r29, 0xFD	; 253
 312:	0f b6       	in	r0, 0x3f	; 63
 314:	f8 94       	cli
 316:	de bf       	out	0x3e, r29	; 62
 318:	0f be       	out	0x3f, r0	; 63
 31a:	cd bf       	out	0x3d, r28	; 61
 31c:	df 91       	pop	r29
 31e:	cf 91       	pop	r28
 320:	1f 91       	pop	r17
 322:	0f 91       	pop	r16
 324:	ff 90       	pop	r15
 326:	ef 90       	pop	r14
 328:	08 95       	ret

0000032a <nrf_advertise>:
	
	// start advertising
	nrf_advertise();
}

void nrf_advertise(void) {
 32a:	cf 93       	push	r28
 32c:	df 93       	push	r29
 32e:	00 d0       	rcall	.+0      	; 0x330 <nrf_advertise+0x6>
 330:	00 d0       	rcall	.+0      	; 0x332 <nrf_advertise+0x8>
 332:	00 d0       	rcall	.+0      	; 0x334 <nrf_advertise+0xa>
 334:	cd b7       	in	r28, 0x3d	; 61
 336:	de b7       	in	r29, 0x3e	; 62
	uint8_t packet[6];
	uart_println((uint8_t *) "Start adv", 9);
 338:	69 e0       	ldi	r22, 0x09	; 9
 33a:	8b ec       	ldi	r24, 0xCB	; 203
 33c:	93 e0       	ldi	r25, 0x03	; 3
 33e:	0e 94 4a 02 	call	0x494	; 0x494 <uart_println>
	packet[0] = 5;		// - len
 342:	85 e0       	ldi	r24, 0x05	; 5
 344:	89 83       	std	Y+1, r24	; 0x01
	packet[1] = 0x0F;	// - connect command
 346:	8f e0       	ldi	r24, 0x0F	; 15
 348:	8a 83       	std	Y+2, r24	; 0x02

	packet[2] = 0x00;	// - timeout
 34a:	1b 82       	std	Y+3, r1	; 0x03
	packet[3] = 0x00;	// - timeout
 34c:	1c 82       	std	Y+4, r1	; 0x04

	packet[4] = 100;	// - AdvInterval
 34e:	84 e6       	ldi	r24, 0x64	; 100
 350:	8d 83       	std	Y+5, r24	; 0x05
	packet[5] = 0;	// - AdvInterval
 352:	1e 82       	std	Y+6, r1	; 0x06
	nrf_send_packet(packet);
 354:	ce 01       	movw	r24, r28
 356:	01 96       	adiw	r24, 0x01	; 1
 358:	0e 94 17 01 	call	0x22e	; 0x22e <nrf_send_packet>
	nrf_wait_for_rdy();
 35c:	0e 94 14 01 	call	0x228	; 0x228 <nrf_wait_for_rdy>
	nrf_receive_packet();
 360:	0e 94 29 01 	call	0x252	; 0x252 <nrf_receive_packet>
}
 364:	26 96       	adiw	r28, 0x06	; 6
 366:	0f b6       	in	r0, 0x3f	; 63
 368:	f8 94       	cli
 36a:	de bf       	out	0x3e, r29	; 62
 36c:	0f be       	out	0x3f, r0	; 63
 36e:	cd bf       	out	0x3d, r28	; 61
 370:	df 91       	pop	r29
 372:	cf 91       	pop	r28
 374:	08 95       	ret

00000376 <nrf_setup>:
	}
}

void nrf_setup(void) {
	// wait till nrf wants to send shit
	nrf_wait_for_rdy();
 376:	0e 94 14 01 	call	0x228	; 0x228 <nrf_wait_for_rdy>
	// send word that nrf wants to send shit
	// this usually the device started packet
	uart_println((uint8_t *) "DeviceStartedEvent", 18);
 37a:	62 e1       	ldi	r22, 0x12	; 18
 37c:	85 ed       	ldi	r24, 0xD5	; 213
 37e:	93 e0       	ldi	r25, 0x03	; 3
 380:	0e 94 4a 02 	call	0x494	; 0x494 <uart_println>
	nrf_wait_for_rdy();
 384:	0e 94 14 01 	call	0x228	; 0x228 <nrf_wait_for_rdy>
	nrf_receive_packet();
 388:	0e 94 29 01 	call	0x252	; 0x252 <nrf_receive_packet>
	uart_println((uint8_t *) "SetupData start", 15);
 38c:	6f e0       	ldi	r22, 0x0F	; 15
 38e:	88 ee       	ldi	r24, 0xE8	; 232
 390:	93 e0       	ldi	r25, 0x03	; 3
 392:	0e 94 4a 02 	call	0x494	; 0x494 <uart_println>
	nrf_send_setup_data();
 396:	0e 94 5a 01 	call	0x2b4	; 0x2b4 <nrf_send_setup_data>
	uart_println((uint8_t *) "SetupData sent", 14);
 39a:	6e e0       	ldi	r22, 0x0E	; 14
 39c:	88 ef       	ldi	r24, 0xF8	; 248
 39e:	93 e0       	ldi	r25, 0x03	; 3
 3a0:	0e 94 4a 02 	call	0x494	; 0x494 <uart_println>
	// recieve transaction complete packet
	// nrf_wait_for_rdy();
	// nrf_receive_packet();
	// recieve device in standby event
	nrf_wait_for_rdy();
 3a4:	0e 94 14 01 	call	0x228	; 0x228 <nrf_wait_for_rdy>
	nrf_receive_packet();
 3a8:	0e 94 29 01 	call	0x252	; 0x252 <nrf_receive_packet>
	
	// start advertising
	nrf_advertise();
 3ac:	0e 94 95 01 	call	0x32a	; 0x32a <nrf_advertise>
 3b0:	08 95       	ret

000003b2 <nrf_send_data>:
	nrf_send_packet(packet);
	nrf_wait_for_rdy();
	nrf_receive_packet();
}

void nrf_send_data(uint8_t *data, uint8_t length) {
 3b2:	ff 92       	push	r15
 3b4:	0f 93       	push	r16
 3b6:	1f 93       	push	r17
 3b8:	cf 93       	push	r28
 3ba:	df 93       	push	r29
 3bc:	00 d0       	rcall	.+0      	; 0x3be <nrf_send_data+0xc>
 3be:	1f 92       	push	r1
 3c0:	cd b7       	in	r28, 0x3d	; 61
 3c2:	de b7       	in	r29, 0x3e	; 62
 3c4:	8c 01       	movw	r16, r24
 3c6:	f6 2e       	mov	r15, r22
	// max data bytes is 20
	if (length > 20)
 3c8:	84 e1       	ldi	r24, 0x14	; 20
 3ca:	86 17       	cp	r24, r22
 3cc:	a0 f0       	brcs	.+40     	; 0x3f6 <nrf_send_data+0x44>
		return;
	uint8_t packet[3] = {2 + length, 0x15, PIPE_UART_OVER_BTLE_UART_TX_TX};
 3ce:	82 e0       	ldi	r24, 0x02	; 2
 3d0:	86 0f       	add	r24, r22
 3d2:	89 83       	std	Y+1, r24	; 0x01
 3d4:	85 e1       	ldi	r24, 0x15	; 21
 3d6:	8a 83       	std	Y+2, r24	; 0x02
 3d8:	83 e0       	ldi	r24, 0x03	; 3
 3da:	8b 83       	std	Y+3, r24	; 0x03

	NRF_START_TRANSMISSION;
 3dc:	28 98       	cbi	0x05, 0	; 5
	nrf_wait_for_rdy();
 3de:	0e 94 14 01 	call	0x228	; 0x228 <nrf_wait_for_rdy>

	spi_tranceive(packet, 3);
 3e2:	63 e0       	ldi	r22, 0x03	; 3
 3e4:	ce 01       	movw	r24, r28
 3e6:	01 96       	adiw	r24, 0x01	; 1
 3e8:	0e 94 0d 02 	call	0x41a	; 0x41a <spi_tranceive>
	spi_tranceive(data, length);
 3ec:	6f 2d       	mov	r22, r15
 3ee:	c8 01       	movw	r24, r16
 3f0:	0e 94 0d 02 	call	0x41a	; 0x41a <spi_tranceive>

	NRF_END_TRANSMISSION;
 3f4:	28 9a       	sbi	0x05, 0	; 5
 3f6:	0f 90       	pop	r0
 3f8:	0f 90       	pop	r0
 3fa:	0f 90       	pop	r0
 3fc:	df 91       	pop	r29
 3fe:	cf 91       	pop	r28
 400:	1f 91       	pop	r17
 402:	0f 91       	pop	r16
 404:	ff 90       	pop	r15
 406:	08 95       	ret

00000408 <spi_init>:
	 * MISO - PB3
	 * RDY  - PB4
	 * RST  - PB5
	*/
	/* Set MOSI and SCK output, all others input */
	DDRB = (1<<NRF_NSS)|(1<<NRF_CLK)|(1<<NRF_MOSI)|(1<<NRF_RST);
 408:	87 e2       	ldi	r24, 0x27	; 39
 40a:	84 b9       	out	0x04, r24	; 4
	// set nss pin, rst pin high
	PORTB |= (1<<NRF_NSS)|(1<<NRF_RST);
 40c:	85 b1       	in	r24, 0x05	; 5
 40e:	81 62       	ori	r24, 0x21	; 33
 410:	85 b9       	out	0x05, r24	; 5
	// enable NRF_RDY pullup
	PORTB |= (1<<NRF_RDY);
 412:	2c 9a       	sbi	0x05, 4	; 5
	/* Enable SPI, Master, LSB first, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<DORD);
 414:	81 e7       	ldi	r24, 0x71	; 113
 416:	8c bd       	out	0x2c, r24	; 44
 418:	08 95       	ret

0000041a <spi_tranceive>:
}

void spi_tranceive(uint8_t *data, uint8_t length){
	for (uint8_t i=0; i<length; i++) {
 41a:	66 23       	and	r22, r22
 41c:	61 f0       	breq	.+24     	; 0x436 <spi_tranceive+0x1c>
 41e:	28 2f       	mov	r18, r24
 420:	e8 2f       	mov	r30, r24
 422:	f9 2f       	mov	r31, r25
		SPDR = *data++;
 424:	81 91       	ld	r24, Z+
 426:	8e bd       	out	0x2e, r24	; 46
		while(!((SPSR)&(1<<SPIF)));
 428:	0d b4       	in	r0, 0x2d	; 45
 42a:	07 fe       	sbrs	r0, 7
 42c:	fd cf       	rjmp	.-6      	; 0x428 <spi_tranceive+0xe>
 42e:	8e 2f       	mov	r24, r30
 430:	82 1b       	sub	r24, r18
	/* Enable SPI, Master, LSB first, set clock rate fck/16 */
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<DORD);
}

void spi_tranceive(uint8_t *data, uint8_t length){
	for (uint8_t i=0; i<length; i++) {
 432:	86 17       	cp	r24, r22
 434:	b8 f3       	brcs	.-18     	; 0x424 <spi_tranceive+0xa>
 436:	08 95       	ret

00000438 <spi_receive>:
}

uint8_t spi_receive(void) {
	uint8_t data = 0;
	// Load data into the buffer
	SPDR = data;
 438:	1e bc       	out	0x2e, r1	; 46
	
	//Wait until transmission complete
	while(!((SPSR)&(1<<SPIF)));
 43a:	0d b4       	in	r0, 0x2d	; 45
 43c:	07 fe       	sbrs	r0, 7
 43e:	fd cf       	rjmp	.-6      	; 0x43a <spi_receive+0x2>
	
	// Return received data
	data = SPDR;
 440:	8e b5       	in	r24, 0x2e	; 46
	return data;
 442:	08 95       	ret

00000444 <uart_init>:
#include "../Include/UART_api.h"

void uart_init(void) {
	// Set baud rate
	UCSR1A = 0;
 444:	e8 ec       	ldi	r30, 0xC8	; 200
 446:	f0 e0       	ldi	r31, 0x00	; 0
 448:	10 82       	st	Z, r1
	// Asynchronous Double Speed mode operation
	UCSR1A = (1<<U2X1);
 44a:	82 e0       	ldi	r24, 0x02	; 2
 44c:	80 83       	st	Z, r24
	//Enable receiver
	UCSR1B = (1<<RXEN1)|(1<<RXCIE1)|(1<<TXEN1)|(1<<TXCIE1);
 44e:	88 ed       	ldi	r24, 0xD8	; 216
 450:	80 93 c9 00 	sts	0x00C9, r24
	//Set frame format: 8data(UCSZ10), 1 stop bit(USBS1)
	UCSR1C = (3<<UCSZ10);
 454:	86 e0       	ldi	r24, 0x06	; 6
 456:	80 93 ca 00 	sts	0x00CA, r24
	//Baud rate 9600 fosc = 16M/8/9600 U2Xn=0 then 12 if U2Xn=1 then 25
	UBRR1=207;
 45a:	8f ec       	ldi	r24, 0xCF	; 207
 45c:	90 e0       	ldi	r25, 0x00	; 0
 45e:	90 93 cd 00 	sts	0x00CD, r25
 462:	80 93 cc 00 	sts	0x00CC, r24
 466:	08 95       	ret

00000468 <uart_print>:
}

void uart_print(uint8_t *data, uint8_t length) {
 468:	cf 93       	push	r28
 46a:	df 93       	push	r29
	uint8_t index;
	for (index=0; index<length; index++) {
 46c:	66 23       	and	r22, r22
 46e:	79 f0       	breq	.+30     	; 0x48e <uart_print+0x26>
 470:	a8 2f       	mov	r26, r24
 472:	b9 2f       	mov	r27, r25
		/* Wait for empty transmit buffer */
		while ( !( UCSR1A & (1<<UDRE1)) );
 474:	e8 ec       	ldi	r30, 0xC8	; 200
 476:	f0 e0       	ldi	r31, 0x00	; 0
		/* Put data into buffer, sends the data */
		UDR1 = *data;
 478:	ce ec       	ldi	r28, 0xCE	; 206
 47a:	d0 e0       	ldi	r29, 0x00	; 0

void uart_print(uint8_t *data, uint8_t length) {
	uint8_t index;
	for (index=0; index<length; index++) {
		/* Wait for empty transmit buffer */
		while ( !( UCSR1A & (1<<UDRE1)) );
 47c:	90 81       	ld	r25, Z
 47e:	95 ff       	sbrs	r25, 5
 480:	fd cf       	rjmp	.-6      	; 0x47c <uart_print+0x14>
		/* Put data into buffer, sends the data */
		UDR1 = *data;
 482:	9d 91       	ld	r25, X+
 484:	98 83       	st	Y, r25
 486:	9a 2f       	mov	r25, r26
 488:	98 1b       	sub	r25, r24
	UBRR1=207;
}

void uart_print(uint8_t *data, uint8_t length) {
	uint8_t index;
	for (index=0; index<length; index++) {
 48a:	96 17       	cp	r25, r22
 48c:	b8 f3       	brcs	.-18     	; 0x47c <uart_print+0x14>
		while ( !( UCSR1A & (1<<UDRE1)) );
		/* Put data into buffer, sends the data */
		UDR1 = *data;
		data++;
	}
}
 48e:	df 91       	pop	r29
 490:	cf 91       	pop	r28
 492:	08 95       	ret

00000494 <uart_println>:

void uart_println(uint8_t *data, uint8_t length) {
	uart_print(data, length);
 494:	0e 94 34 02 	call	0x468	; 0x468 <uart_print>
	while ( !( UCSR1A & (1<<UDRE1)) );
 498:	e8 ec       	ldi	r30, 0xC8	; 200
 49a:	f0 e0       	ldi	r31, 0x00	; 0
 49c:	80 81       	ld	r24, Z
 49e:	85 ff       	sbrs	r24, 5
 4a0:	fd cf       	rjmp	.-6      	; 0x49c <uart_println+0x8>
	UDR1 = '\r';
 4a2:	8d e0       	ldi	r24, 0x0D	; 13
 4a4:	80 93 ce 00 	sts	0x00CE, r24
	while ( !( UCSR1A & (1<<UDRE1)) );
 4a8:	e8 ec       	ldi	r30, 0xC8	; 200
 4aa:	f0 e0       	ldi	r31, 0x00	; 0
 4ac:	80 81       	ld	r24, Z
 4ae:	85 ff       	sbrs	r24, 5
 4b0:	fd cf       	rjmp	.-6      	; 0x4ac <uart_println+0x18>
	UDR1 = '\n';
 4b2:	8a e0       	ldi	r24, 0x0A	; 10
 4b4:	80 93 ce 00 	sts	0x00CE, r24
 4b8:	08 95       	ret

000004ba <__tablejump2__>:
 4ba:	ee 0f       	add	r30, r30
 4bc:	ff 1f       	adc	r31, r31

000004be <__tablejump__>:
 4be:	05 90       	lpm	r0, Z+
 4c0:	f4 91       	lpm	r31, Z
 4c2:	e0 2d       	mov	r30, r0
 4c4:	09 94       	ijmp

000004c6 <_exit>:
 4c6:	f8 94       	cli

000004c8 <__stop_program>:
 4c8:	ff cf       	rjmp	.-2      	; 0x4c8 <__stop_program>
